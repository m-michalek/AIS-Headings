---
title: "Headline"
author: "Tino Wagner, Max Michalek, Lukas Ziebold"
date: "6 Juni 2018"
---

## 1. Einleitung

Talente, die sich auf Honeypot anmelden, werden einem Pre-Screening Prozess aus einem Gespräch und einem Code Review unterzogen. Bestehen Entwickler das Pre-Screening, werden ihre Profile mit einer Headline versehen und in einem „Batch“ veröffentlicht.
Die Headline soll das Profil des Entwicklers kurz und ansprechend zusammenfassen.
Wird ein Talent in einem Batch veröffentlicht, können Unternehmen das Profil des Entwicklers über eine Suche finden und das Talent zu einem Interview einladen. Ist das Unternehmen mit einem Talent zufrieden, hat es die Möglichkeit den- oder diejenige einzustellen. Honeypot erhält bei einer Einstellung 15% des Jahresgehalts als Kommission.

Als Bestandteil des Kurses Analytische Informationssysteme gilt es einen Datensatz der Firma Honeypot GmbH zu analysieren. Inhalt des Datensatz sind die Tabellen *batches*, *talents* und *salaries*. In *talents* werden die Talente mit ihren Attributen, wie z.B. *was_hired*, *was_batched* und *headline*, aufgelistet. Dieser Report befasst sich hauptsächlich mit der Untersuchung der *headline* aus der *talents*-Tabelle. Anders als andere Attribute ist *headline* weder numerisch, noch folgt es einer erkennbaren Struktur wie z.B. *work_roles*. Um Erkenntnisse aus *headlin* zu erlangen, machen wir uns einige Packages zu nutze. *Tidytext* ist essentiell bei der Isolierung einzelner Wörter zu weiteren analyse.

```{r}
#install/load packages: tidyvers, tidytext
#install.packages("magrittr")
#install.packages("tidyverse")
#install.packages("tidytext")
#install.packages("wordcloud")
library(tidyverse)
library(tidytext)
library(magrittr)
library(plyr)
library(dplyr)
library(ggplot2)
library(wordcloud)

#Importieren der Datensätze
batches <- read.csv("./Honeypot_subset/HWR_DATA_batches_subset.csv")
salaries <- read.csv("./Honeypot_subset/HWR_DATA_salaries_subset.csv")
talents <- read.csv("./Honeypot_subset/HWR_DATA_talents_subset.csv")

```

## 2. Der Honeypot-Funnel

Um für das Unternehmen nützliche Informationen zu erschließen, betrachten wir zunächst das Geschäftsmodell von Honeypot. Die Talente können in fünf Kategorien eingeordnet werden: 
*signed up
*invited to call
*batched
*invited to interview
*hired

Um in eine nächste Kategorie eingeordnet zu werden, muss die Vorherige erfüllt sein. Die anteilige Verteilung an Talenten ist trichterförmig, daher die Bezeichnung Honeypot-Funnel. So ergeben sich Conversion-Rates von einer zur nächsten Kategorie. 

Kategorie 		        | Talente 		    | Conversion-Rate
------------- 	      | ------------- 	| -------------
signed up 		        | 61203		        | 
invited to call	      | 12060		        | 19,7%
batched 		          | 8252		        | 68,4%
invited to interview	| 3984		        | 48,3%
hired	 		            | 396		        	| 9,9%

Da Honeypot eine Kommission bei Einstellung eines Talents erhält, möchten wir die Conversion-Rate von batched zu invited to interview und von invited to interview zu hired erhöhen.  

```{r}
# Gesamtanzahl der Talente
talents %>% 
  nrow()

# Alle Talente die zu einem Skype call eingeladen wurden
talents %>% 
  filter(invited_to_call == 1) %>% 
  nrow()

# Anzahl der individuellen Batches
batches %>% 
  nrow()

# Anzahl der zu einem Interview eingeladenen Talente
talents %>% 
  filter(interview_invites > 0, headline != "", was_batched == 1) %>% 
  nrow()

# Anzahl der Talente die Eingestellt wurden
talents %>% 
  filter(was_hired == 1) %>% 
  nrow


# Wordcloud
# Visualisierung der meist genutzen 200 Wörter als Wordcloud
wordcloud(unnested_headlines_total$word[1:200], unnested_headlines_total$n[1:200])
```

## 3. Headlines unter der Lupe

Nahezu alle Talente die als *was_batched* = 1 markiert sind, haben Headline. Aus der Tabelle *batches* lässt sich zeigen, wie viele Talente je *Batch_ID* gebatcht wurden.


Betrachten wir zunächst die Häufigkeit verwendeter Wörter in *headline*.
Dazu filtern wir nach Talents die eine Headline haben. Mit der Methode *unnest_tokens* separieren wir jedes einzelne Keyword. Da nur gehaltvolle Keywords von Bedeutung sind, löschen wir mit *anti_join (stop_words)* alle Füllwörter. Die am meisten verwendeten Keywords stellen wir in diesem Plot dar.

*developer* ist das am häufigsten verwendete Keyword. Folgende Untersuchung zeigt welche Keywords oft mit *developer* auftreten.
 
Zusätzlich analysieren wir das Auftreten von Wörtern in Headlines je *work_role*. Die am häufigsten auftretenden *work_role*s sind *Backend, Fullstack*; *Backend*; *Frontend*; *Mobile* und *Frontend, Fullstack* 

```{r}
# Anzahl von gebatchten Talents pro Batch
B_batches_over_time <- batches %>% 
  group_by(batch_id) %>% 
  count_()

# Visualisierung der Anzahl der gebatchten Talente über alle Batches als line chart
ggplot(B_batches_over_time, aes(x = batch_id, y = n, fill=n)) + 
  geom_line()+
  ylab("Amount of Talents batched")+
  xlab("Batch ID")+
  theme(legend.position = "none")

# Filtern nach allen Talenten mit einer Headline
with_headlines <- talents %>% 
  filter(talents$headline != "")

# Filtern nach allen Talenten ohne einer Headline
without_headlines <- talents %>% 
  filter(talents$headline == "")

# Erstellen eines Data Frames mit "talent_id" und "headline"
headlines_df <- data_frame(talent_id = with_headlines$talent_id, headline = as.vector(with_headlines$headline))

# Aufteilen von einer Headline pro Reihe in ein Wort pro Reihe ohne die Zuordnung zum Talent zu verlieren
unnested_headlines <- headlines_df %>%
  unnest_tokens(word, headline)

# Auflistung der Häufigkeiten wie oft ein Wort pro Headline vorkommt
# Stopwords werden entfernt und nach der Häufigkeit sortiert
word_count <- unnested_headlines %>%
  anti_join(stop_words) %>%
  group_by(talent_id ,word) %>% 
  count_() %>% 
  arrange(-n)
  
# Auflistung der Gesamthäufigkeit der Wörter in den Headlines
word_count_per_talent_id <- word_count %>% 
  group_by(word) %>% 
  count_() %>% 
  arrange(-nn)

colnames(word_count_per_talent_id) <- c("word", "n")

# Anzahl der insgesamt genutzen Wörter pro Talent
word_count_per_headline <- unnested_headlines %>%
  anti_join(stop_words) %>%
  group_by(talent_id) %>% 
  count_() %>% 
  arrange(-n)

# Anpassung der Levels des Factor word für eine passende Reihenfolge beim plotten
word_count_per_talent_id$word <- factor(word_count_per_talent_id$word, levels = word_count_per_talent_id$word)

# Erstellen eines neuen Data Frames für die populärsten 20 Wörter und ihrer Häufigkeit
most_20_words <- data_frame(word = word_count_per_talent_id$word[1:20], n = word_count_per_talent_id$n[1:20])

# Dem neuen Data Frame werden alle weiteren Wörter und ihrer Häufigkeit unter dem Wort "Other words" hinzugefügt
most_20_words <- rbind(most_20_words, data.frame(word = "Other words", n = sum(word_count_per_talent_id$n[21:length(word_count_per_talent_id)])))

# Anpassung der Levels des Factor word für eine passende Reihenfolge beim plotten
most_20_words$word <- factor(most_20_words$word, levels = most_20_words$word)

A_most_20_words <-most_20_words  %>% top_n(20)

# Erstellung eines Colcharts zur visualisierung der populärsten 20 Wörter
# Aus ästhetischen Gründen wurde "Other words" rausgerechnet
most_20_words %>%
  filter (word!="Other words") %>%
  ggplot(aes(x = word, y = n, fill=n)) +
  geom_col()+
  theme(text = element_text(size=20),
        axis.text.x = element_text(angle=90, hjust=1), legend.position = "none")+
  ylab("Count")+
  xlab("Word")

# Auflistung aller Talente welche zu einem Interview eingeladen wurden (12060)
invited_to_call <- talents %>% 
  filter(invited_to_call == 1)

# Auflistung alle Talente die Gebatched wurden, jedoch nicht zu einem Interview eingeladen wurden
talents %>%
  filter(was_batched == 1, interview_invites != 0) %>% 
  count_()

# Auflistung aller Talente die von einem Arbeitgeber eingestellt wurden
talents %>% 
  filter(was_hired == 1) %>% 
  count_()

# Ausgabe aller Talents mit allen Daten, welche als "was_batched" markiert wurden
was_batched <- talents %>% 
  filter(was_batched == 1) %>% 
  left_join(word_count)

# Reduzieren der angezeigten Daten auf "talent_id", "word" und "n"
was_batched <- was_batched[c("talent_id", "word", "n")]

# Errechnen eines Verhältnisses, in wievielen Headlines ist das Wort enthalten / Anzahl der Talente
was_batched <- was_batched %>% 
  count_("word") %>% 
  arrange(-nn) %>% 
  mutate("propability" = nn / was_batched %>% 
           group_by(talent_id) %>% 
           count_() %>% 
           nrow()
         )

# Anpassen der Spaltenbezeichnungen
colnames(was_batched) <- c("word", "n_was_batched", "propability_was_batched")

# Alle Wörter die zu einem Interview geführt haben und deren Häufigkeit in wievielen Headlines das Wort enthalten ist
invited_word_count <- unnested_headlines %>% 
  anti_join(stop_words) %>%
  inner_join(talents) %>% 
  group_by(word) %>% 
  filter(interview_invites > 0) %>%
  count_() %>% 
  arrange(-n)

# Visualisierung der 20 erfolgsversprechenden Wörter
invited_word_count [1:20,] %>%
  arrange(-n) %>%
  ggplot(aes(x = reorder(word, -n) , y = n,fill = n)) +
  geom_col() +
  theme(text = element_text(size=20), axis.text.x = element_text(angle=90, hjust=1), legend.position="none") +
  ylab("Talents invited to Interview") +
  xlab("Word")

# Alle Wörter die in Headlines vorkommen, die von einem Talent benutzt wurden, der eine Einstellung erhalten hat und die Anzahl der Headlines in denen das Wort enthalten ist
hired_word_count <- unnested_headlines %>% 
  anti_join(stop_words) %>%
  inner_join(talents) %>% 
  group_by(word) %>% 
  filter(was_hired == 1)%>%
  count_() %>% 
  arrange(-n)


# Wörter der "work_roles"
with_headlines_work_roles <- with_headlines %>% 
  filter(work_roles != "{}")

# Anzahl der vertretenen Workroles ermittelt
with_headlines_work_roles %>% 
  group_by(work_roles) %>% 
  count_("work_roles") %>% 
  arrange(-n) %>% 
  View()

#-----
# Alle Talents mit einer Headline und der "work_role" "{Backend,Fullstack}"
with_headlines_backend_fullstack <- with_headlines %>% 
  filter(work_roles == "{Backend,Fullstack}")

# Reduzieren der Attribute zu "talent_id" und "headline"
headlines_backend_fullstack_df <- data_frame(talent_id = with_headlines_backend_fullstack$talent_id, headline = as.vector(with_headlines_backend_fullstack$headline))

# Aufteilen von einer Headline pro Reihe in ein Wort pro Reihe ohne die Zuordnung zum Talent zu verlieren
unnested_headlines_backend_fullstack <- headlines_backend_fullstack_df %>%
  unnest_tokens(word, headline)

# Anzahl wie oft die Wörter verwendet wurden
unnested_headlines_backend_fullstack <- unnested_headlines_backend_fullstack %>%
  anti_join(stop_words) %>%
  group_by(word) %>% 
  count_() %>% 
  arrange(-n)

# Wörter in der Workrole "{Backend,Fullstack}"
unnested_headlines_backend_fullstack[1:5,] %>% 
  View()

#-----
# Alle Talents mit einer Headline und der "work_role" "{Backend}"
with_headlines_backend <- with_headlines %>% 
  filter(work_roles == "{Backend}")

# Reduzieren der Attribute zu "talent_id" und "headline"
headlines_backend_df <- data_frame(talent_id = with_headlines_backend$talent_id, headline = as.vector(with_headlines_backend$headline))

# Aufteilen von einer Headline pro Reihe in ein Wort pro Reihe ohne die Zuordnung zum Talent zu verlieren
unnested_headlines_backend <- headlines_backend_df %>%
  unnest_tokens(word, headline)

# Anzahl wie oft die Wörter verwendet wurden
unnested_headlines_backend <- unnested_headlines_backend %>%
  anti_join(stop_words) %>%
  group_by(word) %>% 
  count_() %>% 
  arrange(-n)

# Wörter in der Workrole "{Backend}"
unnested_headlines_backend[1:5,] %>% 
  View()

#-----
# Alle Talents mit einer Headline und der "work_role" "{Frontend}"
with_headlines_frontend <- with_headlines %>% 
  filter(work_roles == "{Frontend}")

# Reduzieren der Attribute zu "talent_id" und "headline"
headlines_frontend_df <- data_frame(talent_id = with_headlines_frontend$talent_id, headline = as.vector(with_headlines_frontend$headline))

# Aufteilen von einer Headline pro Reihe in ein Wort pro Reihe ohne die Zuordnung zum Talent zu verlieren
unnested_headlines_frontend <- headlines_frontend_df %>%
  unnest_tokens(word, headline)

# Anzahl wie oft die Wörter verwendet wurden
unnested_headlines_frontend <- unnested_headlines_frontend %>%
  anti_join(stop_words) %>%
  group_by(word) %>% 
  count_() %>% 
  arrange(-n)

# Wörter in der Workrole "{Frontend}"
unnested_headlines_frontend[1:5,] %>% 
  View()

#-----
# Alle Talents mit einer Headline und der "work_role" "{Mobile}"
with_headlines_mobile <- with_headlines %>% 
  filter(work_roles == "{Mobile}")

# Reduzieren der Attribute zu "talent_id" und "headline"
headlines_mobile_df <- data_frame(talent_id = with_headlines_mobile$talent_id, headline =
as.vector(with_headlines_mobile$headline))

# Aufteilen von einer Headline pro Reihe in ein Wort pro Reihe ohne die Zuordnung zum Talent zu verlieren
unnested_headlines_mobile <- headlines_mobile_df %>%
  unnest_tokens(word, headline)

# Anzahl wie oft die Wörter verwendet wurden
unnested_headlines_mobile <- unnested_headlines_mobile %>%
  anti_join(stop_words) %>%
  group_by(word) %>% 
  count_() %>% 
  arrange(-n)

# Wörter in der Workrole "{Mobile}"
unnested_headlines_mobile[1:5,] %>% 
  View()
  
#-----
# Alle Talents mit einer Headline und der "work_role" "{Frontend,Fullstack}"
with_headlines_frontend_fullstack <- with_headlines %>% 
  filter(work_roles == "{Frontend,Fullstack}")

# Reduzieren der Attribute zu "talent_id" und "headline"
headlines_frontend_fullstack_df <- data_frame(talent_id = with_headlines_frontend_fullstack$talent_id, headline = as.vector(with_headlines_frontend_fullstack$headline))

# Aufteilen von einer Headline pro Reihe in ein Wort pro Reihe ohne die Zuordnung zum Talent zu verlieren
unnested_headlines_frontend_fullstack <- headlines_frontend_fullstack_df %>%
  unnest_tokens(word, headline)

# Anzahl wie oft die Wörter verwendet wurden
unnested_headlines_frontend_fullstack <- unnested_headlines_frontend_fullstack %>%
  anti_join(stop_words) %>%
  group_by(word) %>% 
  count_() %>% 
  arrange(-n)

# Wörter in der Workrole "{Frontend,Fullstack}"
unnested_headlines_frontend_fullstack[1:5,] %>% 
  View()

#----
# Gesamtübersicht top 5 work roles
top_5_words_per_work_role <- data_frame("{Backend,Fullstack}" = unnested_headlines_backend_fullstack$word[1:5],"{Backend,Fullstack} n" = unnested_headlines_backend_fullstack$n[1:5], "{Backend}" = unnested_headlines_backend$word[1:5], "{Backend} n" = unnested_headlines_backend$n[1:5], "{Frontend}" = unnested_headlines_frontend$word[1:5], "{Frontend} n" = unnested_headlines_frontend$n[1:5],  "{Mobile}" = unnested_headlines_mobile$word[1:5], "{Mobile} n" = unnested_headlines_mobile$n[1:5], "{Frontend,Fullstack}" = unnested_headlines_frontend_fullstack$word[1:5],  "{Frontend,Fullstack} n" = unnested_headlines_frontend_fullstack$n[1:5])

# Plot der top 5 "{Backend,Fullstack}"
unnested_headlines_backend_fullstack[1:5,] %>% 
  ggplot(aes(x = word, y = n)) +
  geom_col() 

# Plot der top 5 "{Backend}""
unnested_headlines_backend[1:5,] %>% 
  ggplot(aes(x = word, y = n)) +
  geom_col() 

# Plot der top 5 "{Frontend}""
unnested_headlines_frontend[1:5,] %>% 
  ggplot(aes(x = word, y = n)) +
  geom_col()

# Plot der top 5 "{Mobile}""
unnested_headlines_mobile[1:5,] %>% 
  ggplot(aes(x = word, y = n)) +
  geom_col() 

# Plot der top 5 "{Frontend,Fullstack}""
unnested_headlines_frontend_fullstack[1:5,] %>% 
  ggplot(aes(x = word, y = n)) +
  geom_col() 

```

## 4. Einfluss der Wörter 

Um eine mögliche Relation von einem Wort zu anderen Attributen zu finden, untersuchen wir die Talente die ein bestimmtes Wort in ihrer Headline verwendet haben. Diese Gruppe wird nach *interview_invites > 0* gefiltert und der Kontrollgruppe die das jeweilige Wort nicht verwendet hat und eingeladen wurde, gegenübergestellt. 
Folgendes Balkendiagramm zeigt die Interviewquote bei Verwendung eines Wortes. 

Vergleichen wir nun diese Erkenntnis mit der Kontrollgruppe, erhalten wir den Einfluss (Impact) den die Verwendung eines Keywords auf die Interviewquote hat.

Derselbe Vergleich in Bezug auf die Einstellungsquote gibt folgendes Ergebnis.

Es ist zu erkennen, das z.B. *berlin* einen positiven Einfluss auf die Möglichkeit der Einladung zu einem Interview hat. Auf der anderen Seite hat *opportunity* einen negativen Einfluss. 

```{r}
# Anzahl der Talents die gebatched wurden und "developer" in der Headline verwendet haben
word_count %>% 
  filter(word == "developer") %>% 
  inner_join(talents) %>% 
  filter(interview_invites > 0) %>% 
  nrow() %>% 
  View()

# Talente die "developer" in der Headline verwendet haben
developer_in_headline <- word_count %>% 
  filter(word == "developer") %>% 
  inner_join(talents) %>% 
  filter(interview_invites > 0)

# Talente die "experience" in der Headline verwendet haben
experience_in_headline <- word_count %>% 
  filter(word == "experience") %>% 
  inner_join(talents) %>% 
  filter(interview_invites > 0)

# Talente die "engineer" in der Headline verwendet haben
engineer_in_headline <- word_count %>% 
  filter(word == "engineer") %>% 
  inner_join(talents) %>% 
  filter(interview_invites > 0)

# Talente die "senior" in der Headline verwendet haben
senior_in_headline <- word_count %>% 
  filter(word == "senior") %>% 
  inner_join(talents) %>% 
  filter(interview_invites > 0)

# Talente die "position" in der Headline verwendet haben
position_in_headline <- word_count %>% 
  filter(word == "position") %>% 
  inner_join(talents) %>% 
  filter(interview_invites > 0)

# Talente die "experienced" in der Headline verwendet haben
experienced_in_headline <- word_count %>% 
  filter(word == "experienced") %>% 
  inner_join(talents) %>% 
  filter(interview_invites > 0)

# Talente die "fullstack" in der Headline verwendet haben
fullstack_in_headline <- word_count %>% 
  filter(word == "fullstack") %>% 
  inner_join(talents) %>% 
  filter(interview_invites > 0)

# Talente die "java" in der Headline verwendet haben
java_in_headline <- word_count %>% 
  filter(word == "java") %>% 
  inner_join(talents) %>% 
  filter(interview_invites > 0)

# Talente die "backend" in der Headline verwendet haben
backend_in_headline <- word_count %>% 
  filter(word == "backend") %>% 
  inner_join(talents) %>% 
  filter(interview_invites > 0)

# Talente die "frontend" in der Headline verwendet haben
frontend_in_headline <- word_count %>% 
  filter(word == "frontend") %>% 
  inner_join(talents) %>% 
  filter(interview_invites > 0)

# Talente die "javascript" in der Headline verwendet haben
javascript_in_headline <- word_count %>% 
  filter(word == "javascript") %>% 
  inner_join(talents) %>% 
  filter(interview_invites > 0)

# Talente die "python" in der Headline verwendet haben
python_in_headline <- word_count %>% 
  filter(word == "python") %>% 
  inner_join(talents) %>% 
  filter(interview_invites > 0)

# Talente die "software" in der Headline verwendet haben
software_in_headline <- word_count %>% 
  filter(word == "software") %>% 
  inner_join(talents) %>% 
  filter(interview_invites > 0)

# Talente die "php" in der Headline verwendet haben
php_in_headline <- word_count %>% 
  filter(word == "php") %>% 
  inner_join(talents) %>% 
  filter(interview_invites > 0)

# Talente die "lead" in der Headline verwendet haben
lead_in_headline <- word_count %>% 
  filter(word == "lead") %>% 
  inner_join(talents) %>% 
  filter(interview_invites > 0)

# Talente die "ruby" in der Headline verwendet haben
ruby_in_headline <- word_count %>% 
  filter(word == "ruby") %>% 
  inner_join(talents) %>% 
  filter(interview_invites > 0)

# Talente die "opportunity" in der Headline verwendet haben
opportunity_in_headline <- word_count %>% 
  filter(word == "opportunity") %>% 
  inner_join(talents) %>% 
  filter(interview_invites > 0)

# Talente die "berlin" in der Headline verwendet haben
berlin_in_headline <- word_count %>% 
  filter(word == "berlin") %>% 
  inner_join(talents) %>% 
  filter(interview_invites > 0)

# Talente die "data_in_headline" in der Headline verwendet haben
data_in_headline <- word_count %>% 
  filter(word == "data") %>% 
  inner_join(talents) %>% 
  filter(interview_invites > 0)

# Talente die "team" in der Headline verwendet haben
team_in_headline <- word_count %>% 
  filter(word == "team") %>% 
  inner_join(talents) %>% 
  filter(interview_invites > 0)

# Talente die "developer" nicht in der Headline verwendet haben
no_developer_in_headline <- with_headlines %>% 
  anti_join(filter(word_count, word == "developer"), by = "talent_id")

# Talente die "experience" nicht in der Headline verwendet haben
no_experience_in_headline <- with_headlines %>% 
  anti_join(filter(word_count, word == "experience"), by = "talent_id")

# Talente die "engineer" nicht in der Headline verwendet haben
no_engineer_in_headline <- with_headlines %>% 
  anti_join(filter(word_count, word == "engineer"), by = "talent_id")

# Talente die "senior" nicht in der Headline verwendet haben
no_senior_in_headline <- with_headlines %>% 
  anti_join(filter(word_count, word == "senior"), by = "talent_id")

# Talente die "position" nicht in der Headline verwendet haben
no_position_in_headline <- with_headlines %>% 
  anti_join(filter(word_count, word == "position"), by = "talent_id")

# Talente die "experienced" nicht in der Headline verwendet haben
no_experienced_in_headline <- with_headlines %>% 
  anti_join(filter(word_count, word == "experienced"), by = "talent_id")

# Talente die "fullstack" nicht in der Headline verwendet haben
no_fullstack_in_headline <- with_headlines %>% 
  anti_join(filter(word_count, word == "fullstack"), by = "talent_id")

# Talente die "java" nicht in der Headline verwendet haben
no_java_in_headline <- with_headlines %>% 
  anti_join(filter(word_count, word == "java"), by = "talent_id")

# Talente die "backend" nicht in der Headline verwendet haben
no_backend_in_headline <- with_headlines %>% 
  anti_join(filter(word_count, word == "backend"), by = "talent_id")

# Talente die "frontend" nicht in der Headline verwendet haben
no_frontend_in_headline <- with_headlines %>% 
  anti_join(filter(word_count, word == "frontend"), by = "talent_id")

# Talente die "javascript" nicht in der Headline verwendet haben
no_javascript_in_headline <- with_headlines %>% 
  anti_join(filter(word_count, word == "javascript"), by = "talent_id")

# Talente die "python" nicht in der Headline verwendet haben
no_python_in_headline <- with_headlines %>% 
  anti_join(filter(word_count, word == "python"), by = "talent_id")

# Talente die "software" nicht in der Headline verwendet haben
no_software_in_headline <- with_headlines %>% 
  anti_join(filter(word_count, word == "software"), by = "talent_id")

# Talente die "php" nicht in der Headline verwendet haben
no_php_in_headline <- with_headlines %>% 
  anti_join(filter(word_count, word == "php"), by = "talent_id")

# Talente die "lead" nicht in der Headline verwendet haben
no_lead_in_headline <- with_headlines %>% 
  anti_join(filter(word_count, word == "lead"), by = "talent_id")

# Talente die "ruby" nicht in der Headline verwendet haben
no_ruby_in_headline <- with_headlines %>% 
  anti_join(filter(word_count, word == "ruby"), by = "talent_id")

# Talente die "opportunity" nicht in der Headline verwendet haben
no_opportunity_in_headline <- with_headlines %>% 
  anti_join(filter(word_count, word == "opportunity"), by = "talent_id")

# Talente die "berlin" nicht in der Headline verwendet haben
no_berlin_in_headline <- with_headlines %>% 
  anti_join(filter(word_count, word == "berlin"), by = "talent_id")

# Talente die "data" nicht in der Headline verwendet haben
no_data_in_headline <- with_headlines %>% 
  anti_join(filter(word_count, word == "data"), by = "talent_id")

# Talente die "team" nicht in der Headline verwendet haben
no_team_in_headline <- with_headlines %>% 
  anti_join(filter(word_count, word == "team"), by = "talent_id")

# Talente die "developer" nicht in der Headline verwendet haben
no_developer_in_headline %>% 
  filter(interview_invites > 0) 

# Talente die "experience" nicht in der Headline verwendet haben
no_experience_in_headline %>% 
  filter(interview_invites > 0)

# Talente die "engineer" nicht in der Headline verwendet haben
no_engineer_in_headline %>% 
  filter(interview_invites > 0)

# Talente die "senior" nicht in der Headline verwendet haben
no_senior_in_headline %>% 
  filter(interview_invites > 0)

# Talente die "position" nicht in der Headline verwendet haben
no_position_in_headline %>% 
  filter(interview_invites > 0)

# Alle 20 am häufigsten verwendeten Wörter, mit der Anzahl an Headlines in denen sie enthalten sind, Anzahl an Headlines die das Wort genutzt haben und zu einem Interview eingeladen wurden, Anzahl von Headlines die das Wort nicht genutzt haben und Anzahl der Headlines die das Wort nicht genutzt haben und zu einem Interview eingeladen wurden
B_top_20_words <- most_20_words [1:20,] %>% 
  mutate("used_invite" = c(
    nrow(developer_in_headline), 
    nrow(experience_in_headline), 
    nrow(engineer_in_headline), 
    nrow(senior_in_headline), 
    nrow(position_in_headline), 
    nrow(experienced_in_headline),
    nrow(fullstack_in_headline), 
    nrow(java_in_headline),
    nrow(backend_in_headline),
    nrow(frontend_in_headline),
    nrow(javascript_in_headline),
    nrow(python_in_headline),
    nrow(software_in_headline),
    nrow(php_in_headline),
    nrow(lead_in_headline),
    nrow(ruby_in_headline),
    nrow(opportunity_in_headline),
    nrow(berlin_in_headline),
    nrow(data_in_headline),
    nrow(team_in_headline)
    
    ),
    
    
    "total_not_used" = c(
    nrow(no_developer_in_headline), 
    nrow(no_experience_in_headline), 
    nrow(no_engineer_in_headline), 
    nrow(no_senior_in_headline), 
    nrow(no_position_in_headline), 
    nrow(no_experienced_in_headline), 
    nrow(no_fullstack_in_headline),
    nrow(no_java_in_headline),
    nrow(no_backend_in_headline),
    nrow(no_frontend_in_headline),
    nrow(no_javascript_in_headline),
    nrow(no_python_in_headline),
    nrow(no_software_in_headline),
    nrow(no_php_in_headline),
    nrow(no_lead_in_headline),
    nrow(no_ruby_in_headline),
    nrow(no_opportunity_in_headline),
    nrow(no_berlin_in_headline),
    nrow(no_data_in_headline),
    nrow(no_team_in_headline)
    
    ), 
    "total_not_used_invited" = c(
    nrow(filter(no_developer_in_headline, interview_invites > 0)), 
    nrow(filter(no_experience_in_headline, interview_invites > 0)), 
    nrow(filter(no_engineer_in_headline, interview_invites > 0)), 
    nrow(filter(no_senior_in_headline, interview_invites > 0)), 
    nrow(filter(no_position_in_headline, interview_invites > 0)),
    nrow(filter(no_experienced_in_headline, interview_invites > 0)),
    nrow(filter(no_fullstack_in_headline, interview_invites > 0)),
    nrow(filter(no_java_in_headline, interview_invites > 0)),
    nrow(filter(no_backend_in_headline, interview_invites > 0)),
    nrow(filter(no_frontend_in_headline, interview_invites > 0)),
    nrow(filter(no_javascript_in_headline, interview_invites > 0)),
    nrow(filter(no_python_in_headline, interview_invites > 0)),
    nrow(filter(no_software_in_headline, interview_invites > 0)),
    nrow(filter(no_php_in_headline, interview_invites > 0)),
    nrow(filter(no_lead_in_headline, interview_invites > 0)),
    nrow(filter(no_ruby_in_headline, interview_invites > 0)),
    nrow(filter(no_opportunity_in_headline, interview_invites > 0)),
    nrow(filter(no_berlin_in_headline, interview_invites > 0)),
    nrow(filter(no_data_in_headline, interview_invites > 0)),
    nrow(filter(no_team_in_headline, interview_invites > 0))
      
      ))



# Erweiterung von Informationen:
# 1. Verhältnis: Wort genutzt und eingeladen zu Headlines mit Wort
# 2. Verhältnis: Wort nicht genutzt und einladung zu Wort nicht genutzt
# 3. Verhältnis: 1. Verhältnis zu 2. Verhältnis
B_top_20_words <-  B_top_20_words %>% 
  mutate("perC_used_invite" = used_invite / n, "perC_not_used_invite" = total_not_used_invited / total_not_used, "Impact"=(perC_used_invite / perC_not_used_invite - 1)*100)

# Visualisierung des 3. Verhältnisses anhand der top 20 Wörter
B_top_20_words %>% 
  ggplot(aes(x = word, y = Impact, fill= Impact)) +
  geom_col()+
  theme(text = element_text(size=20), axis.text.x = element_text(angle=90, hjust=1),legend.position="none")+
  ggtitle("Impact of Words on Invite Rate")+
  ylab("Impact in %")+
  xlab("Word")
  
# Visualisierung der Verhältnisse 1. und 2. anhand der top 20 Wörter
B_top_20_words %>% 
  ggplot(aes(x = word, y = perC_used_invite*100,fill = perC_used_invite)) +
  geom_col()+
  theme(text = element_text(size=20), axis.text.x = element_text(angle=90, hjust=1),legend.position="none")+
  ylab("Interview Invites in %")+
  xlab("Word")

B_top_5_words <- most_20_words[1:5,] %>% 
  mutate("used_invite" = c(nrow(developer_in_headline), nrow(experience_in_headline), nrow(engineer_in_headline), nrow(senior_in_headline), nrow(position_in_headline)), "total_not_used" = c(nrow(no_developer_in_headline), nrow(no_experience_in_headline), nrow(no_engineer_in_headline), nrow(no_senior_in_headline), nrow(no_position_in_headline)), "total_not_used_invited" = c(nrow(filter(no_developer_in_headline, interview_invites > 0)), nrow(filter(no_experience_in_headline, interview_invites > 0)), nrow(filter(no_engineer_in_headline, interview_invites > 0)), nrow(filter(no_senior_in_headline, interview_invites > 0)), nrow(filter(no_position_in_headline, interview_invites > 0))))

B_top_5_words <-  B_top_5_words %>% 
  mutate("%_used_invite" = used_invite / n, "%_not_used_invite" = total_not_used_invited / total_not_used)

B_top_5_words %>% 
  ggplot(aes(x = word, y = "%_used_invite", fill = used_invite)) +
  geom_col()

# Anzahl der Talents die eingestellt wurden und "developer" in der Headline verwendet haben
hire_developer_in_headline <- word_count %>% 
  filter(word == "developer") %>% 
  inner_join(talents) %>% 
  filter(was_hired == 1)

# Anzahl der Talents die eingestellt wurden und "experience" in der Headline verwendet haben
hire_experience_in_headline <- word_count %>% 
  filter(word == "experience") %>% 
  inner_join(talents) %>% 
  filter(was_hired == 1)

# Anzahl der Talents die eingestellt wurden und "engineer" in der Headline verwendet haben
hire_engineer_in_headline <- word_count %>% 
  filter(word == "engineer") %>% 
  inner_join(talents) %>% 
  filter(was_hired == 1)

# Anzahl der Talents die eingestellt wurden und "senior" in der Headline verwendet haben
hire_senior_in_headline <- word_count %>% 
  filter(word == "senior") %>% 
  inner_join(talents) %>% 
  filter(was_hired == 1)

# Anzahl der Talents die eingestellt wurden und "position" in der Headline verwendet haben
hire_position_in_headline <- word_count %>% 
  filter(word == "position") %>% 
  inner_join(talents) %>% 
  filter(was_hired == 1)

# Anzahl der Talents die eingestellt wurden und "experienced" in der Headline verwendet haben
hire_experienced_in_headline <- word_count %>% 
  filter(word == "experienced") %>% 
  inner_join(talents) %>% 
  filter(was_hired == 1)

# Anzahl der Talents die eingestellt wurden und "fullstack" in der Headline verwendet haben
hire_fullstack_in_headline <- word_count %>% 
  filter(word == "fullstack") %>% 
  inner_join(talents) %>% 
  filter(was_hired == 1)

# Anzahl der Talents die eingestellt wurden und "java" in der Headline verwendet haben
hire_java_in_headline <- word_count %>% 
  filter(word == "java") %>% 
  inner_join(talents) %>% 
  filter(was_hired == 1)

# Anzahl der Talents die eingestellt wurden und "backend" in der Headline verwendet haben
hire_backend_in_headline <- word_count %>% 
  filter(word == "backend") %>% 
  inner_join(talents) %>% 
  filter(was_hired == 1)

# Anzahl der Talents die eingestellt wurden und "frontend" in der Headline verwendet haben
hire_frontend_in_headline <- word_count %>% 
  filter(word == "frontend") %>% 
  inner_join(talents) %>% 
  filter(was_hired == 1)

# Anzahl der Talents die eingestellt wurden und "javascript" in der Headline verwendet haben
hire_javascript_in_headline <- word_count %>% 
  filter(word == "javascript") %>% 
  inner_join(talents) %>% 
  filter(was_hired == 1)

# Anzahl der Talents die eingestellt wurden und "python" in der Headline verwendet haben
hire_python_in_headline <- word_count %>% 
  filter(word == "python") %>% 
  inner_join(talents) %>% 
  filter(was_hired == 1)

# Anzahl der Talents die eingestellt wurden und "software" in der Headline verwendet haben
hire_software_in_headline <- word_count %>% 
  filter(word == "software") %>% 
  inner_join(talents) %>% 
  filter(was_hired == 1)

# Anzahl der Talents die eingestellt wurden und "php" in der Headline verwendet haben
hire_php_in_headline <- word_count %>% 
  filter(word == "php") %>% 
  inner_join(talents) %>% 
  filter(was_hired == 1)

# Anzahl der Talents die eingestellt wurden und "lead" in der Headline verwendet haben
hire_lead_in_headline <- word_count %>% 
  filter(word == "lead") %>% 
  inner_join(talents) %>% 
  filter(was_hired == 1)

# Anzahl der Talents die eingestellt wurden und "ruby" in der Headline verwendet haben
hire_ruby_in_headline <- word_count %>% 
  filter(word == "ruby") %>% 
  inner_join(talents) %>% 
  filter(was_hired == 1)

# Anzahl der Talents die eingestellt wurden und "opportunity" in der Headline verwendet haben
hire_opportunity_in_headline <- word_count %>% 
  filter(word == "opportunity") %>% 
  inner_join(talents) %>% 
  filter(was_hired == 1)

# Anzahl der Talents die eingestellt wurden und "berlin" in der Headline verwendet haben
hire_berlin_in_headline <- word_count %>% 
  filter(word == "berlin") %>% 
  inner_join(talents) %>% 
  filter(was_hired == 1)

# Anzahl der Talents die eingestellt wurden und "data" in der Headline verwendet haben
hire_data_in_headline <- word_count %>% 
  filter(word == "data") %>% 
  inner_join(talents) %>% 
  filter(was_hired == 1)

# Anzahl der Talents die eingestellt wurden und "team" in der Headline verwendet haben
hire_team_in_headline <- word_count %>% 
  filter(word == "team") %>% 
  inner_join(talents) %>% 
  filter(was_hired == 1)

# Anzahl der Talents die eingestellt wurden und "developer" nicht in der Headline verwendet haben
hire_no_developer_in_headline <- with_headlines %>% 
  anti_join(filter(word_count, word == "developer"), by = "talent_id")

# Anzahl der Talents die eingestellt wurden und "experience" nicht in der Headline verwendet haben
hire_no_experience_in_headline <- with_headlines %>% 
  anti_join(filter(word_count, word == "experience"), by = "talent_id")

# Anzahl der Talents die eingestellt wurden und "engineer" nicht in der Headline verwendet haben
hire_no_engineer_in_headline <- with_headlines %>% 
  anti_join(filter(word_count, word == "engineer"), by = "talent_id")

# Anzahl der Talents die eingestellt wurden und "senior" nicht in der Headline verwendet haben
hire_no_senior_in_headline <- with_headlines %>% 
  anti_join(filter(word_count, word == "senior"), by = "talent_id")

# Anzahl der Talents die eingestellt wurden und "position" nicht in der Headline verwendet haben
hire_no_position_in_headline <- with_headlines %>% 
  anti_join(filter(word_count, word == "position"), by = "talent_id")

# Anzahl der Talents die eingestellt wurden und "experienced" nicht in der Headline verwendet haben
hire_no_experienced_in_headline <- with_headlines %>% 
  anti_join(filter(word_count, word == "experienced"), by = "talent_id") 

# Anzahl der Talents die eingestellt wurden und "fullstack" nicht in der Headline verwendet haben
hire_no_fullstack_in_headline <- with_headlines %>% 
  anti_join(filter(word_count, word == "fullstack"), by = "talent_id") 

# Anzahl der Talents die eingestellt wurden und "java" nicht in der Headline verwendet haben
hire_no_java_in_headline <- with_headlines %>% 
  anti_join(filter(word_count, word == "java"), by = "talent_id") 

# Anzahl der Talents die eingestellt wurden und "backend" nicht in der Headline verwendet haben
hire_no_backend_in_headline <- with_headlines %>% 
  anti_join(filter(word_count, word == "backend"), by = "talent_id") 

# Anzahl der Talents die eingestellt wurden und "frontend" nicht in der Headline verwendet haben
hire_no_frontend_in_headline <- with_headlines %>% 
  anti_join(filter(word_count, word == "frontend"), by = "talent_id") 

# Anzahl der Talents die eingestellt wurden und "javascript" nicht in der Headline verwendet haben
hire_no_javascript_in_headline <- with_headlines %>% 
  anti_join(filter(word_count, word == "javascript"), by = "talent_id") 

# Anzahl der Talents die eingestellt wurden und "python" nicht in der Headline verwendet haben
hire_no_python_in_headline <- with_headlines %>% 
  anti_join(filter(word_count, word == "python"), by = "talent_id") 

# Anzahl der Talents die eingestellt wurden und "software" nicht in der Headline verwendet haben
hire_no_software_in_headline <- with_headlines %>% 
  anti_join(filter(word_count, word == "software"), by = "talent_id")

# Anzahl der Talents die eingestellt wurden und "php" nicht in der Headline verwendet haben
hire_no_php_in_headline <- with_headlines %>% 
  anti_join(filter(word_count, word == "php"), by = "talent_id")

# Anzahl der Talents die eingestellt wurden und "lead" nicht in der Headline verwendet haben
hire_no_lead_in_headline <- with_headlines %>% 
  anti_join(filter(word_count, word == "lead"), by = "talent_id")

# Anzahl der Talents die eingestellt wurden und "ruby" nicht in der Headline verwendet haben
hire_no_ruby_in_headline <- with_headlines %>% 
  anti_join(filter(word_count, word == "ruby"), by = "talent_id")

# Anzahl der Talents die eingestellt wurden und "opportunity" nicht in der Headline verwendet haben
hire_no_opportunity_in_headline <- with_headlines %>% 
  anti_join(filter(word_count, word == "opportunity"), by = "talent_id")

# Anzahl der Talents die eingestellt wurden und "berlin" nicht in der Headline verwendet haben
hire_no_berlin_in_headline <- with_headlines %>% 
  anti_join(filter(word_count, word == "berlin"), by = "talent_id")

# Anzahl der Talents die eingestellt wurden und "data" nicht in der Headline verwendet haben
hire_no_data_in_headline <- with_headlines %>% 
  anti_join(filter(word_count, word == "data"), by = "talent_id")

# Anzahl der Talents die eingestellt wurden und "team" nicht in der Headline verwendet haben
hire_no_team_in_headline <- with_headlines %>% 
  anti_join(filter(word_count, word == "team"), by = "talent_id")



# Alle 20 am häufigsten verwendeten Wörter, mit der Anzahl an Headlines in denen sie enthalten sind, Anzahl an Headlines die das Wort genutzt haben und eingestellt wurden, Anzahl von Headlines die das Wort nicht genutzt haben und Anzahl der Headlines die das Wort nicht genutzt haben und eingestellt wurden
C_hire_words <- most_20_words [1:20,] %>% 
  mutate("used_hired" = c(
    nrow(hire_developer_in_headline), 
    nrow(hire_experience_in_headline), 
    nrow(hire_engineer_in_headline), 
    nrow(hire_senior_in_headline), 
    nrow(hire_position_in_headline), 
    nrow(hire_experienced_in_headline),
    nrow(hire_fullstack_in_headline), 
    nrow(hire_java_in_headline),
    nrow(hire_backend_in_headline),
    nrow(hire_frontend_in_headline),
    nrow(hire_javascript_in_headline),
    nrow(hire_python_in_headline),
    nrow(hire_software_in_headline),
    nrow(hire_php_in_headline),
    nrow(hire_lead_in_headline),
    nrow(hire_ruby_in_headline),
    nrow(hire_opportunity_in_headline),
    nrow(hire_berlin_in_headline),
    nrow(hire_data_in_headline),
    nrow(hire_team_in_headline)
    
    ),
    
    
    "total_not_used" = c(
    nrow(hire_no_developer_in_headline), 
    nrow(hire_no_experience_in_headline), 
    nrow(hire_no_engineer_in_headline), 
    nrow(hire_no_senior_in_headline), 
    nrow(hire_no_position_in_headline), 
    nrow(hire_no_experienced_in_headline), 
    nrow(hire_no_fullstack_in_headline),
    nrow(hire_no_java_in_headline),
    nrow(hire_no_backend_in_headline),
    nrow(hire_no_frontend_in_headline),
    nrow(hire_no_javascript_in_headline),
    nrow(hire_no_python_in_headline),
    nrow(hire_no_software_in_headline),
    nrow(hire_no_php_in_headline),
    nrow(hire_no_lead_in_headline),
    nrow(hire_no_ruby_in_headline),
    nrow(hire_no_opportunity_in_headline),
    nrow(hire_no_berlin_in_headline),
    nrow(hire_no_data_in_headline),
    nrow(hire_no_team_in_headline)
    
    ), 
    "total_not_used_hired" = c(
    nrow(filter(hire_no_developer_in_headline, was_hired == 1)), 
    nrow(filter(hire_no_experience_in_headline, was_hired == 1)), 
    nrow(filter(hire_no_engineer_in_headline, was_hired == 1)), 
    nrow(filter(hire_no_senior_in_headline, was_hired == 1)), 
    nrow(filter(hire_no_position_in_headline, was_hired == 1)),
    nrow(filter(hire_no_experienced_in_headline, was_hired == 1)),
    nrow(filter(hire_no_fullstack_in_headline, was_hired == 1)),
    nrow(filter(hire_no_java_in_headline, was_hired == 1)),
    nrow(filter(hire_no_backend_in_headline, was_hired == 1)),
    nrow(filter(hire_no_frontend_in_headline, was_hired == 1)),
    nrow(filter(hire_no_javascript_in_headline, was_hired == 1)),
    nrow(filter(hire_no_python_in_headline, was_hired == 1)),
    nrow(filter(hire_no_software_in_headline, was_hired == 1)),
    nrow(filter(hire_no_php_in_headline, was_hired == 1)),
    nrow(filter(hire_no_lead_in_headline, was_hired == 1)),
    nrow(filter(hire_no_ruby_in_headline, was_hired == 1)),
    nrow(filter(hire_no_opportunity_in_headline, was_hired == 1)),
    nrow(filter(hire_no_berlin_in_headline, was_hired == 1)),
    nrow(filter(hire_no_data_in_headline, was_hired == 1)),
     nrow(filter(hire_no_team_in_headline, was_hired == 1))
      
      ))



# Erweiterung von Informationen:
# 1. Verhältnis: Wort genutzt und eingestellt zu Headlines mit Wort
# 2. Verhältnis: Wort nicht genutzt und eingestellt zu Wort nicht genutzt
# 3. Verhältnis: 1. Verhältnis zu 2. Verhältnis
C_hire_words <-  C_hire_words %>% 
  mutate("perC_used_hired" = used_hired / n, "perC_not_used_hired" = total_not_used_hired / total_not_used, "Impact"=(perC_used_hired / perC_not_used_hired - 1)*100)

# Visualisierung des 3. Verhältnisses anhand der top 20 Wörter
C_hire_words %>% 
  ggplot(aes(x = word, y = Impact, fill= Impact)) +
  geom_col() +
  theme(text = element_text(size = 20), axis.text.x = element_text(angle = 90, hjust = 1), legend.position = "none") +
  ylab("Impact in %") +
  xlab("Word")

# Visualisierung der Verhältnisse 1. und 2. anhand der top 20 Wörter
C_hire_words %>% 
  ggplot(aes(x = word, y = perC_used_invite*100, fill = perC_used_invite)) +
  geom_col() +
  theme(text = element_text(size = 20), axis.text.x = element_text(angle = 90, hjust = 1), legend.position = "none") +
  ylab("Hired in %") +
  xlab("Word")

```

## 5. Weitere Erkenntnisse

Im Verlauf der Analyse des Datensatzes der Honeypot GmbH fallen einige Inkonsistenzen der Daten auf. 

* 270 Talente in Tabelle batches, die in Tabelle talents was_batched=0 sind
* 7 Talente *headline != “”*, *was_batched==1*
* 9 Talente *was_hired==1*, *was_batched==0*
* Work Roles lassen sich schlecht voneinander abgrenzen, da es nur eine Headline pro Talent gibt. Besser wäre eine Headline pro Work Role
* Work Roles sollten vor dem Speichern geordnet werden damit keine überflüssigen kombinationen abgelegt werden
* Teilweise werden Work Roles mit Anführungszeichen gespeichert

## 6. Analyse der Wort und Dokumenten Frequenz tf-idf

Ansatz der folgenden Analyse war es, die Wichtigkeit der in den Headlines vorkommenden Wörter herauszufinden. Da das einfache betrachten der Häufigkeit kein aussagekräftiges ergebnis liefert, haben wir uns der  Technik der “term inverse document frequency” (idf) bedient. Diese Technik reduziert die Gewichtung von Wörtern die öfter vorkommen und erhöht die Gewichtung von Wörtern die weniger oft  in einer Sammlung von Dokumenten, in unserem Falle Headlines vorkommen. Unsere Ergebnisse sind nicht sehr Aussagekräftig da wir jede einzelne Headline als eigenes Dokument angesehen haben. Die Aussagekraft könnte enorm verbessert werden, indem alle Headlines einer bestimmten Work Role zu einem Dokument verknüpft werden würden und die Analyse bezogen auf die Work Roles wiederholt. Des weiteren war es und möglich, Wörter die oft miteinander im Zusammenhang erwähnt wurden zu analysieren und konnten herausfinden welche arten von Developer in den Headlines vertreten sind. Wir haben eine Liste an Wörtern die vor dem Wort Developer genannt worden sind ermittelt und konnten die verschiedenen Programmiersprachen oder Entwickler Typen extrahieren.


```{r}
# what worked was to get words which were oftent used in combination with a given word
headlines_bigrams <- headlines_df %>%
  unnest_tokens(bigram, headline, token = "ngrams", n = 2)

headlines_bigrams %>%
  count_("bigram", sort = TRUE) %>% 
  View()

library(tidyr)

bigrams_separated <- headlines_bigrams %>%
  separate(bigram, c("word1", "word2"), sep = " ")

bigrams_filtered <- bigrams_separated %>%
  filter(!word1 %in% stop_words$word) %>%
  filter(!word2 %in% stop_words$word)

# new bigram counts:
bigram_counts <- bigrams_filtered %>% 
  dplyr::count(word1, word2)

bigram_counts

bigrams_united <- bigrams_filtered %>%
  unite(bigram, word1, word2, sep = " ")

bigrams_united

bigrams_filtered %>%
  dplyr::filter(word2 == "developer") %>%
  dplyr::count(talent_id, word1, sort = TRUE) %>% 
  View()

developer_types <- bigrams_filtered %>%
  dplyr::filter(word2 == "developer") %>%
  dplyr::count(talent_id, word1, sort = TRUE) %>% 
  group_by(word1) %>% 
  dplyr::count_() %>% 
  arrange(-nn)

developer_types[1:10,] %>% 
  ggplot(aes(x = reorder(word1, -nn), y = nn)) +
  geom_col() +
  xlab("Häufigst erwähnte Wörter im Zusammenhang mit developer") +
  ylab("n")

#install.packages("igraph")
library(igraph)

# original counts
bigram_counts

bigram_graph <- bigram_counts %>%
  filter(n > 20) %>%
  graph_from_data_frame()

bigram_graph

#install.packages("ggraph")
library(ggraph)
set.seed(2017)

# Leider haben wir es nicht hinbekommen eine anschauliche Visualisierung der Beziehungen der einzelnen Wörter zueinander zu plotten da wir jedes mal auf eine Fehlermeldung gestoßen sind
ggraph::ggraph(bigram_graph, layout = "fr") +
  geom_edge_link() +
  geom_node_point() +
  geom_node_text(aes(label = name), vjust = 1, hjust = 1)
```


## 7. Nicht Vollendete Versuche
```{r}
# Welche Wörter waren die 5 meist verwendetsten pro Monat

#install.packages("scales")
#install.packages("zoo")

library(scales)
library(zoo)

# Refactoring des Datenformats "created_at" zu einem Date Format
batches$created_at <- as.Date(batches$created_at)

# Erstellen eines neuen Attributes mit dem Format Monat Jahr
batches$month_year <- as.yearmon(batches$created_at)

# Die benutzten Wörter und ihre Anzahl pro Batch(Pro Monat und Jahr)
batches %>% 
  left_join(unnested_headlines) %>% 
  anti_join(stop_words) %>% 
  group_by(month_year) %>% 
  count_("word") %>% 
  View()

# Alle Talente die gebatched wurden, jedoch nicht als gebatched markiert wurden
talent_id_and_count_error_was_batched <- batches %>% 
  left_join(unnested_headlines) %>% 
  left_join(talents) %>%
  filter(was_batched == 0) %>% 
  group_by(talent_id) %>% 
  count_() %>% 
  View()

# Anzahl der Talente die gebatched wurden, jedoch nicht als gebatched markiert wurden
error_was_batched <- batches %>% 
  left_join(unnested_headlines) %>% 
  left_join(talents) %>%
  filter(was_batched == 0) %>% 
  group_by(talent_id) %>% 
  count_() %>% 
  nrow()

# TODO
#ggplot colchart/barchar 1. Balken count was_batched // 2. Balken was batched in batches aber was_batched == 0

# Visualisierung des Verhältnisses zwischen als batched markierte Talente und anzahl der gebatcheten Talente in der batches.csv
data_frame( was_bached = c("talents","batches"), n = c(nrow(with_headlines_was_batched), error_was_batched + nrow(with_headlines_was_batched))) %>% 
  ggplot(aes(x = was_bached, y = n)) +
  geom_col()

# Alle Wörter die in einem Batch enthalten waren und deren Häufigkeit
batches %>% 
  left_join(unnested_headlines) %>% 
  anti_join(stop_words) %>% 
  group_by(month_year, word) %>% 
  count_() %>% 
  View()
```

headline vs !headline
```{r}
# Alle Talente mit einer Headline die gebatched wurden
with_headlines_was_batched <- with_headlines %>% 
  filter(was_batched == 1)  

# Talente die ohne einer Headline gebatched wurden (7 Stück)
without_headlines_was_batched <- without_headlines %>% 
  filter(was_batched == 1) 

# Alle Talente die eine Headline haben und eingestellt worden sind
with_headlines_was_hired <- with_headlines %>% 
  filter(was_hired == 1)

# Alle Talente die keine Headline haben und eingestellt worden sind
without_headlines_was_hired <- without_headlines %>% 
  filter(was_hired == 1)

# Visualisierung des Verhältnisses zwischen Batches und Headlines
# Erkenntis: Um gebatched zu werden braucht man eine Headline
data_frame( headline = c("headline","no headline"), n = c(nrow(with_headlines_was_batched), nrow(without_headlines_was_batched))) %>% 
  ggplot(aes(x = headline, y = n)) +
  geom_col()+
  ggtitle("Batched Talents")+
  ylab("Count")+
  xlab("Headline")

# Visualisierung des Verhältnisses zwischen Batches und Einstellungen
# Erkenntis: Um gehired zu werden muss man gebatched werden (ausnahme von 9)
data_frame( headline = rev(c("was_not_batched","was_batched")), n = c(nrow(with_headlines_was_hired), nrow(without_headlines_was_hired))) %>% 
  ggplot(aes(x = headline, y = n)) +
  geom_col()+
  ggtitle("Hired Talents")+
  ylab("Count")+
  xlab("Hired")

# Ausnahmen: 9 wurden gehired ohne batch
was_hired_without_batched <- talents %>% 
  filter(was_hired == 1, was_batched == 0)


headlines_df_was_hired <- data_frame(talent_id = filter(with_headlines, was_hired == 1)$talent_id, headline = as.vector(filter(with_headlines, was_hired == 1)$headline))

unnested_headlines_was_hired <- headlines_df_was_hired %>%
  unnest_tokens(word, headline) %>% 
  anti_join(stop_words) %>% 
  group_by(word) %>% 
  count_() %>% 
  arrange(-n)

unnested_headlines_total <- headlines_df %>%
  unnest_tokens(word, headline) %>% 
  anti_join(stop_words) %>% 
  group_by(word) %>% 
  count_() %>% 
  arrange(-n)

# Versuch jedem Wort eine Wahrscheinlichkeit zuordnen die zum hired führt
hired_words_propability <- inner_join(unnested_headlines_was_hired, unnested_headlines_total, by = "word")

colnames(hired_words_propability) <- c("word", "n_hired", "n_total")

hired_words_propability <- hired_words_propability %>% 
  mutate(propability = n_hired / n_total )


# ----------------------------------------------------
developer_talents <- unnested_headlines %>% 
  filter(word == "developer") %>% 
  group_by(talent_id) %>% 
  count_() %>% 
  arrange(-n)

developer_talents <- developer_talents %>% 
  inner_join(talents)

summary(developer_talents)

# Workexperience headline vs workexperience developer
developer_talents_workexperience <- developer_talents %>% 
  group_by(work_experience) %>% 
  count_()

talents_workexperience <- talents %>% 
  group_by(work_experience) %>% 
  count_()

developer_talents_workexperience <- developer_talents_workexperience %>% 
  filter(work_experience != "") %>% 
  mutate(verhaeltnis = nn/sum(nn))

talents_workexperience <- talents_workexperience %>% 
  filter(work_experience != "", n != 1) %>% 
  mutate(verhaeltnis = n/sum(n))

colnames(developer_talents_workexperience) <- c("work_experience", "n_developer", "verhältnis_developer")

joined_work_experience <- inner_join(developer_talents_workexperience, talents_workexperience)

ggplot(joined_work_experience, aes(x = work_experience, y = verhältnis_developer)) +
geom_col()

# Workexperience hired 
# workexperience total vs workexperience hired 

```


DATA ANALYZATION

Salaries

```{r}
# Übersicht der Gehälter
summary(salaries)

# order by talents hired by city  hi-lo
salaries %>%
  group_by(city) %>%
  summarise(n=n()) %>% 
  arrange(-n) 

# Durchschnittliches Mindestgehalt pro Stadt
salaries %>%
  group_by(city) %>%
  summarise(average_sal_min=mean(minimum,na.rm=TRUE)) %>%  
  arrange(-average_sal_min)

# Durchschnittliches Maximalgehalt pro Stadt
salaries %>%
  group_by(city) %>%
  summarise(average_sal_max=mean(maximum,na.rm=TRUE)) %>%  
  arrange(-average_sal_max)

```

Talents

```{r}
summary(talents)

talents <- HWR_DATA_talents_subset %>% 
  filter(grepl('AngularJS',headline) & was_hired %in% '1') %>% 
  filter(grepl("\\d",headline) | grepl("\\w",headline))

summary(no_headline)

```